import { _ as _export_sfc, r as resolveComponent, o as openBlock, c as createElementBlock, b as createBaseVNode, d as createTextVNode, e as createVNode, a as createStaticVNode } from "./app-d515af8b.js";
const _sfc_main = {};
const _hoisted_1 = /* @__PURE__ */ createBaseVNode(
  "h2",
  {
    id: "前言",
    tabindex: "-1"
  },
  [
    /* @__PURE__ */ createBaseVNode("a", {
      class: "header-anchor",
      href: "#前言",
      "aria-hidden": "true"
    }, "#"),
    /* @__PURE__ */ createTextVNode(" 前言")
  ],
  -1
  /* HOISTED */
);
const _hoisted_2 = /* @__PURE__ */ createBaseVNode(
  "p",
  null,
  "如何构建 Kubernetes 所需的容器镜像？我想你答案肯定是 Docker，没错，Docker 确实是首选。我们在使用 Jenkins 进行 CI/CD构建容器镜像的时候，做法通常是将 Jenkins 服务部署在物理机上，然后使用物理机的 docker build 命令来构建镜像。但是在 Jenkins on K8s 环境下，Jenkins Master 和 Jenkins Slave 都以 Pod 形式运行在 Kubernetes 集群的 Node 上，我们的构建环境都是 Pod ，没有 docker 命令。众所周知 Kubernetes 在 V1.24.x 版本之后默认采用 containerd 作为容器运行时，不再支持 Docker，我们想用宿主机上的 /var/run/docker.sock 也用不了了。 我们就需要另一种方式在 Kubernetes 集群中构建容器镜像，本文将介绍 Kaniko工具。",
  -1
  /* HOISTED */
);
const _hoisted_3 = /* @__PURE__ */ createBaseVNode(
  "h2",
  {
    id: "什么是kaniko",
    tabindex: "-1"
  },
  [
    /* @__PURE__ */ createBaseVNode("a", {
      class: "header-anchor",
      href: "#什么是kaniko",
      "aria-hidden": "true"
    }, "#"),
    /* @__PURE__ */ createTextVNode(" 什么是Kaniko")
  ],
  -1
  /* HOISTED */
);
const _hoisted_4 = /* @__PURE__ */ createBaseVNode(
  "img",
  {
    src: "https://img.kubesre.com/kubesre/20230913/Kaniko-Logo.png",
    alt: ""
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_5 = {
  href: "https://github.com/GoogleContainerTools/kaniko",
  target: "_blank",
  rel: "noopener noreferrer"
};
const _hoisted_6 = /* @__PURE__ */ createStaticVNode('<ul><li>docker in docker</li><li>不依赖 Docker守护进程</li><li>不需要 privilege 权限，安全构建</li><li>仅需一条命令</li><li>支持 Dockerfile 构建</li></ul><p>现在，让我们一步一步来探索 Kaniko</p><h2 id="在kubernetes中使用kaniko" tabindex="-1"><a class="header-anchor" href="#在kubernetes中使用kaniko" aria-hidden="true">#</a> 在Kubernetes中使用Kaniko</h2><p>Kaniko 以容器的方式来运行的，同时需要三个参数: Dockerfile，上下文，以及远端镜像仓库的地址。</p><p><img src="https://img.kubesre.com/kubesre/20230913/image.png" alt="image.png"> 工作原理：</p><ol><li>读取并解析指定的Dockerfile</li><li>提取基础镜像的文件系统（Dockerfile 中的 FROM 镜像）</li><li>在独立的Dockerfile中分别运行每个命令</li><li>每次运行后都会对用户空间文件系统的做快照</li><li>每次运行时，将快照层附加到基础层并更新镜像元数据</li><li>最后推送镜像</li></ol><p>前提条件：</p><ul><li>需要一个运行的 kubernetes 集群</li><li>需要创建一个 Kubernetes secret，其中包含推送到镜像仓库所需的身份验证信息</li><li>需要准备好Dockerfile</li></ul><h2 id="创建dockerfile" tabindex="-1"><a class="header-anchor" href="#创建dockerfile" aria-hidden="true">#</a> 创建Dockerfile</h2><p>编写一个Dockerfile 文件，并创建configmap 在k8s中：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cat Dockerfile</span>\nFROM ubuntu\nENTRYPOINT <span class="token punctuation">[</span><span class="token string">&quot;/bin/bash&quot;</span>, <span class="token string">&quot;-c&quot;</span>, <span class="token string">&quot;echo hello&quot;</span><span class="token punctuation">]</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># kubectl create configmap kaniko-dockerfile --from-file=./Dockerfile</span>\nconfigmap/kaniko-dockerfile created\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="创建镜像仓库凭证的secret" tabindex="-1"><a class="header-anchor" href="#创建镜像仓库凭证的secret" aria-hidden="true">#</a> 创建镜像仓库凭证的Secret</h2><p>创建一个配置kaniko推送到 阿里云镜像仓库的凭证，找一台有安装docker的机子，登录仓库</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># docker login --username=xxx registry.cn-shanghai.aliyuncs.com</span>\nPassword:\nWARNING<span class="token operator">!</span> Your password will be stored unencrypted <span class="token keyword">in</span> /root/.docker/config.json.\nConfigure a credential helper to remove this warning. See\nhttps://docs.docker.com/engine/reference/commandline/login/<span class="token comment">#credentials-store</span>\n \nLogin Succeeded\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>登入成功之后，会生成一个config.json的文件，使用该文件创建一个secret供kaniko容器使用。</p><ul><li>centos环境中文件位置：/root/.docker/config.json</li><li>ubuntu环境中文件位置：/home/ubuntu/.docker/config.json</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># kubectl create secret generic kaniko-secret --from-file=/root/.docker/config.json</span>\nsecret/kaniko-secret created\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="启动kaniko容器用来构建镜像" tabindex="-1"><a class="header-anchor" href="#启动kaniko容器用来构建镜像" aria-hidden="true">#</a> 启动kaniko容器用来构建镜像</h2><p>kaniko_build_image.yaml：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: kaniko\nspec:\n  containers:\n  - name: kaniko\n    image: gcr.io/kaniko-project/executor:latest\n    args: <span class="token punctuation">[</span><span class="token string">&quot;--dockerfile=/workspace/Dockerfile&quot;</span>,\n            <span class="token string">&quot;--context=dir://workspace&quot;</span>,\n            <span class="token string">&quot;--destination=registry.cn-shanghai.aliyuncs.com/kubesre02/kaniko-demo:1.0&quot;</span><span class="token punctuation">]</span> <span class="token comment"># 替换成自己的仓库地址</span>\n    volumeMounts:\n      - name: kaniko-secret\n        mountPath: /kaniko/.docker\n      - name: dockerfile\n        mountPath: /workspace\n  volumes:\n    - name: kaniko-secret\n      secret:\n        secretName: kaniko-secret\n        items:\n          - key: config.json\n            path: config.json\n    - name: dockerfile\n      configMap:\n        name: kaniko-dockerfile\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>args 部分</li></ul><p>这部分就是上面所讲的，kaniko运行时需要三个参数: Dockerfile(--dockerfile)，上下文(--context)，远端镜像仓库(--destination)</p><ul><li>secret 部分</li></ul><p>推送至指定远端镜像仓库需要认证，所以以secret的方式挂载到/kaniko/.docker/这个目录下，文件名称为config.json</p><p>创建pod，查看状态，并看log是否正常完成。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># kubectl apply -f kaniko_build_image.yaml</span>\npod/kaniko created\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># kubectl get pod</span>\nNAME                       READY   STATUS    RESTARTS   AGE\nkaniko                     <span class="token number">1</span>/1     Running   <span class="token number">0</span>          3s\n \n<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># kubectl logs -f kaniko</span>\nINFO<span class="token punctuation">[</span>0000<span class="token punctuation">]</span> Retrieving image manifest ubuntu            \nINFO<span class="token punctuation">[</span>0000<span class="token punctuation">]</span> Retrieving image ubuntu from registry index.docker.io\nINFO<span class="token punctuation">[</span>0003<span class="token punctuation">]</span> Built cross stage deps: map<span class="token punctuation">[</span><span class="token punctuation">]</span>               \nINFO<span class="token punctuation">[</span>0003<span class="token punctuation">]</span> Retrieving image manifest ubuntu            \nINFO<span class="token punctuation">[</span>0003<span class="token punctuation">]</span> Returning cached image manifest             \nINFO<span class="token punctuation">[</span>0003<span class="token punctuation">]</span> Executing <span class="token number">0</span> build triggers                  \nINFO<span class="token punctuation">[</span>0003<span class="token punctuation">]</span> Building stage <span class="token string">&#39;ubuntu&#39;</span> <span class="token punctuation">[</span>idx: <span class="token string">&#39;0&#39;</span>, base-idx: <span class="token string">&#39;-1&#39;</span><span class="token punctuation">]</span>\nINFO<span class="token punctuation">[</span>0003<span class="token punctuation">]</span> Skipping unpacking as no commands require it.\nINFO<span class="token punctuation">[</span>0003<span class="token punctuation">]</span> ENTRYPOINT <span class="token punctuation">[</span><span class="token string">&quot;/bin/bash&quot;</span>, <span class="token string">&quot;-c&quot;</span>, <span class="token string">&quot;echo hello&quot;</span><span class="token punctuation">]</span>\nINFO<span class="token punctuation">[</span>0003<span class="token punctuation">]</span> Pushing image to registry.cn-shanghai.aliyuncs.com/kubesre02/kaniko-demo:1.0\nINFO<span class="token punctuation">[</span>0004<span class="token punctuation">]</span> Pushed registry.cn-shanghai.aliyuncs.com/kubesre02/kaniko-demo@sha256:d1855cc00550f9048c88b507626e0f24acf4c22e02856e006b2b9fdb0b80e567\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看阿里云镜像仓库已经上传上去了 <img src="https://img.kubesre.com/kubesre/20230913/123.png" alt="image.png"> 用kaniko生成的镜像来测试下是否可用：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># docker run -it --rm registry.cn-shanghai.aliyuncs.com/kubesre02/kaniko-demo:1.0</span>\nUnable to <span class="token function">find</span> image <span class="token string">&#39;registry.cn-shanghai.aliyuncs.com/kubesre02/kaniko-demo:1.0&#39;</span> locally\n<span class="token number">1.0</span>: Pulling from kubesre02/kaniko-demo\n445a6a12be2b: Pull complete\nDigest: sha256:49bb962115b70a15a99b87e48fda28a883758081e41aef14766833d3a1578069\nStatus: Downloaded newer image <span class="token keyword">for</span> registry.cn-shanghai.aliyuncs.com/kubesre02/kaniko-demo:1.0\nhello\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>出来hello即成功。</p><h2 id="自定义一个kaniko镜像" tabindex="-1"><a class="header-anchor" href="#自定义一个kaniko镜像" aria-hidden="true">#</a> 自定义一个Kaniko镜像</h2><p>官方 kaniko 镜像是基于 scratch 构建的，里面没有 shell，想在 kaniko 原生镜像里在调用 shell 命令是很麻烦的。所以我们可以自定义我们自己私有的 Kaniko 镜像。 kaniko 的关键文件其实是/kaniko目录下的二进制文件，官方推荐是用 gcr.io/kaniko-project/executor 镜像，我们就可以拷贝这个/kaniko目录下的 executor 到我们自己的私有镜像 Dockerfile：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>\nFROM gcr.io/kaniko-project/executor:latest AS plugin\n \nFROM ubuntu\n \nENV DOCKER_CONFIG /kaniko/.docker\n \nCOPY <span class="token parameter variable">--from</span><span class="token operator">=</span>plugin /kaniko/executor /usr/local/bin/kaniko\n \nRUN <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /kaniko/.docker/\nCOPY config.json /kaniko/.docker/\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面 Dockerfile 构建了一个基于Ubuntu的Docker镜像，</p>', 35);
const _hoisted_41 = {
  href: "http://gcr.io/kaniko-project/executor:latest",
  target: "_blank",
  rel: "noopener noreferrer"
};
const _hoisted_42 = {
  href: "http://gcr.io/kaniko-project/executor:latest",
  target: "_blank",
  rel: "noopener noreferrer"
};
const _hoisted_43 = /* @__PURE__ */ createBaseVNode(
  "li",
  null,
  "这个步骤是在一个已经包含了Kaniko工具的Docker镜像中构建一个中间容器。",
  -1
  /* HOISTED */
);
const _hoisted_44 = /* @__PURE__ */ createStaticVNode("<li>FROM ubuntu <ul><li>接下来创建一个新的Docker镜像，基于官方的Ubuntu基础镜像。</li></ul></li><li>ENV DOCKER_CONFIG /kaniko/.docker <ul><li>设置环境变量DOCKER_CONFIG为/kaniko/.docker，这是Kaniko工具使用的Docker配置目录。这是为了确保Kaniko可以找到必要的Docker配置信息。</li></ul></li><li>COPY --from=plugin /kaniko/executor /usr/local/bin/kaniko <ul><li>从之前构建的plugin阶段的镜像中复制/kaniko/executor文件到新的镜像的/usr/local/bin/kaniko路径下。这将把Kaniko二进制文件复制到新的Ubuntu镜像中，以便后续在该镜像中使用。</li></ul></li><li>RUN mkdir -p /kaniko/.docker/ <ul><li>在新的镜像中创建/kaniko/.docker/目录，用于存放Docker配置文件。</li></ul></li><li>COPY config.json /kaniko/.docker/ <ul><li>将本地的config.json文件复制到新的镜像的/kaniko/.docker/目录下。这个config.json文件很可能包含了Docker仓库的认证信息和其他配置，以便Kaniko可以访问和推送Docker镜像。</li></ul></li>", 5);
const _hoisted_49 = /* @__PURE__ */ createStaticVNode('<p>最终，这个Docker镜像将包含了Ubuntu操作系统和Kaniko工具，并配置了Kaniko所需的Docker环境，使得可以在容器内使用Kaniko构建Docker镜像，并且有了 shell 环境，同时保持了一定程度的隔离性和安全性。 构建并上传镜像：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># docker build -t registry.cn-shanghai.aliyuncs.com/kubesre02/kaniko:latest .</span>\nSending build context to Docker daemon  <span class="token number">212</span>.1MB\nStep <span class="token number">1</span>/6 <span class="token builtin class-name">:</span> FROM gcr.io/kaniko-project/executor:latest AS plugin\n ---<span class="token operator">&gt;</span> 03375da0f864\nStep <span class="token number">2</span>/6 <span class="token builtin class-name">:</span> FROM ubuntu\n ---<span class="token operator">&gt;</span> aa786d622bb0\nStep <span class="token number">3</span>/6 <span class="token builtin class-name">:</span> ENV DOCKER_CONFIG /kaniko/.docker\n ---<span class="token operator">&gt;</span> Using cache\n ---<span class="token operator">&gt;</span> f7cd726aa130\nStep <span class="token number">4</span>/6 <span class="token builtin class-name">:</span> COPY <span class="token parameter variable">--from</span><span class="token operator">=</span>plugin /kaniko/executor /usr/local/bin/kaniko\n ---<span class="token operator">&gt;</span> Using cache\n ---<span class="token operator">&gt;</span> 8fcac536196f\nStep <span class="token number">5</span>/6 <span class="token builtin class-name">:</span> RUN <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /kaniko/.docker/\n ---<span class="token operator">&gt;</span> Using cache\n ---<span class="token operator">&gt;</span> 1afce75446a3\nStep <span class="token number">6</span>/6 <span class="token builtin class-name">:</span> COPY config.json /kaniko/.docker/\n ---<span class="token operator">&gt;</span> Using cache\n ---<span class="token operator">&gt;</span> 4a2873a75a7c\nSuccessfully built 4a2873a75a7c\nSuccessfully tagged registry.cn-shanghai.aliyuncs.com/kubesre02/kaniko:latest\n \n<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># docker push registry.cn-shanghai.aliyuncs.com/kubesre02/kaniko:latest</span>\nThe push refers to repository <span class="token punctuation">[</span>registry.cn-shanghai.aliyuncs.com/kubesre02/kaniko<span class="token punctuation">]</span>\n0cb4fb37580b: Pushed\nc9dbd3644e5a: Pushed\n33a2214b827c: Pushed\nc5077dd8160b: Pushed\n948c7f86fd48: Pushed\n403aab81b15b: Pushed\n7bff100f35cb: Pushed\nlatest: digest: sha256:b5642885f1333a757625cbe36a9b1102aba27646f2572acab79861a74dba1050 size: <span class="token number">1783</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="kaniko-更多参数" tabindex="-1"><a class="header-anchor" href="#kaniko-更多参数" aria-hidden="true">#</a> Kaniko 更多参数</h2><ol><li>--context：指定构建上下文的路径。默认情况下，上下文是Dockerfile所在的目录。可简写 -c</li><li>--dockerfile：指定要使用的Dockerfile的路径。默认情况下，Kaniko会在上下文中查找名为Dockerfile的文件。 可简写 -f</li><li>--destination：指定构建完成后的Docker镜像名称，可以包括标签。例如：myregistry/myimage:tag。 可简写 -d</li><li>--cache：启用或禁用Kaniko的构建缓存功能。默认情况下，缓存是启用的。</li><li>--cache-ttl：设置构建缓存的生存时间。例如，--cache-ttl=10h表示缓存在构建完成后的10小时内有效。</li><li>--cache-repo：指定用于存储构建缓存的Docker仓库。默认情况下，缓存存储在本地。</li><li>--cache-dir：指定用于存储构建缓存的本地目录路径。</li><li>--skip-tls-verify：跳过TLS证书验证，用于不安全的Docker仓库。</li><li>--build-arg：传递构建参数给Dockerfile中的ARG指令。例如：--build-arg key=value。</li><li>--insecure：允许从不受信任的Registry拉取基础镜像。</li><li>--insecure-registry：允许连接到不受信任的Registry。</li><li>--verbosity：设置构建的详细程度，可以是panic、error、warning、info、debug或trace。</li><li>--digest-file：指定一个文件，用于存储构建生成的镜像的摘要（Digest）。</li><li>--oci-layout-path：指定OCI（Open Container Initiative）布局文件的路径，用于存储构建过程的元数据。</li></ol>', 4);
const _hoisted_53 = {
  href: "https://github.com/GoogleContainerTools/kaniko#additional-flags",
  target: "_blank",
  rel: "noopener noreferrer"
};
const _hoisted_54 = /* @__PURE__ */ createStaticVNode('<h2 id="kaniko-构建缓存" tabindex="-1"><a class="header-anchor" href="#kaniko-构建缓存" aria-hidden="true">#</a> Kaniko 构建缓存</h2><p>--cache-copy-layers 此参数在执行命令之前 kaniko 会检查层的缓存，如果存在 kaniko将拉取并提取缓存层，而不是执行命令。如果没有 kaniko将执行命令，然后将新创建的层推送到缓存。 用户可以通过设置 --cache=true 参数决定是否启用缓存，并且可以通过--cache-repo 标志提供用于存储缓存层的远程存储库，如果未提供此标志则将从提供的 –destination 推断缓存的repo。 通常 --cache=true --cache-copy-layers=true 这两个参数同时使用。</p><h2 id="ci-cd-中使用kaniko" tabindex="-1"><a class="header-anchor" href="#ci-cd-中使用kaniko" aria-hidden="true">#</a> CI/CD 中使用Kaniko</h2><h3 id="jenkins-pipline-中使用" tabindex="-1"><a class="header-anchor" href="#jenkins-pipline-中使用" aria-hidden="true">#</a> jenkins pipline 中使用</h3><p>基于 Kubernetes 的 动态生成 Jenkins Slave pod CI/CD，以下是一个简化的Pipeline示例：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>// 镜像仓库地址\ndef registry <span class="token operator">=</span> <span class="token string">&quot;registry.cn-shanghai.aliyuncs.com/kubesre02/demo&quot;</span>\n \npipeline <span class="token punctuation">{</span>\n    agent <span class="token punctuation">{</span>\n        kubernetes <span class="token punctuation">{</span>\n      yaml <span class="token string">&quot;&quot;</span>&quot;\nkind: Pod\nmetadata:\n  name: kaniko\nspec:\n  containers:\n  - name: kaniko\n    <span class="token comment"># 使用自定义的 kaniko 镜像</span>\n    image: registry.cn-shanghai.aliyuncs.com/kubesre02/kaniko:latest\n    imagePullPolicy: Always\n    command:\n    - <span class="token function">cat</span>\n    tty: <span class="token boolean">true</span>\n<span class="token string">&quot;&quot;</span>&quot;\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n   \n    stages <span class="token punctuation">{</span>\n        stage<span class="token punctuation">(</span><span class="token string">&#39;拉代码&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            steps <span class="token punctuation">{</span>\n                <span class="token function">git</span> clone <span class="token punctuation">..</span>.\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n       \n        stage<span class="token punctuation">(</span><span class="token string">&#39;构建镜像&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            steps <span class="token punctuation">{</span>\n                // 使用 kaniko 来构建镜像\n                container<span class="token punctuation">(</span>name: <span class="token string">&#39;kaniko&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                    Dockerfile 内容<span class="token punctuation">..</span>.\n                    <span class="token function">sh</span> <span class="token string">&quot;kaniko -f Dockerfile -c ./ -d <span class="token variable">$registry</span>:<span class="token variable">$BUILD_NUMBER</span> --force&quot;</span>\n                <span class="token punctuation">}</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n         \n        stage<span class="token punctuation">(</span><span class="token string">&#39;部署&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            steps <span class="token punctuation">{</span>\n                部署<span class="token punctuation">..</span>.\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n         \n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出，Kaniko 是非常适合在Kubernetes平台上构建容器镜像的，而且易于集成到 DevOps Jenkins pipeline 里，好了，kaniko 就介绍到这里。</p>', 7);
function _sfc_render(_ctx, _cache) {
  const _component_ExternalLinkIcon = resolveComponent("ExternalLinkIcon");
  return openBlock(), createElementBlock("div", null, [
    _hoisted_1,
    _hoisted_2,
    _hoisted_3,
    createBaseVNode("p", null, [
      _hoisted_4,
      createTextVNode(" Github地址："),
      createBaseVNode("a", _hoisted_5, [
        createTextVNode("https://github.com/GoogleContainerTools/kaniko"),
        createVNode(_component_ExternalLinkIcon)
      ]),
      createTextVNode(" Kaniko 是Google开源的一款在 Kubernetes 用来构建容器镜像的工具，它是一个从 Dockerfile 构建容器镜像的工具，就像 Docker 一样，但主要区别在于 Kaniko 可以在容器内运行，这意味着它可以在 Kubernetes 集群内运行。不需要特权模式，也不需要公开任何套接字。不需要在我们集群的节点上运行 Docker，因此我们使用哪个容器引擎来运行容器并不重要。重要的是 Kaniko 可以在容器内构建容器镜像，并在 Kubernetes 集群内自动构建，这就和宿主机上的 Docker 解绑了，更加安全可靠。特点如下：")
    ]),
    _hoisted_6,
    createBaseVNode("ol", null, [
      createBaseVNode("li", null, [
        createTextVNode("FROM "),
        createBaseVNode("a", _hoisted_41, [
          createTextVNode("gcr.io/kaniko-project/executor:latest"),
          createVNode(_component_ExternalLinkIcon)
        ]),
        createTextVNode(" AS plugin "),
        createBaseVNode("ul", null, [
          createBaseVNode("li", null, [
            createTextVNode("从名为"),
            createBaseVNode("a", _hoisted_42, [
              createTextVNode("gcr.io/kaniko-project/executor:latest"),
              createVNode(_component_ExternalLinkIcon)
            ]),
            createTextVNode("的Docker镜像开始构建一个临时阶段，并将其命名为plugin。")
          ]),
          _hoisted_43
        ])
      ]),
      _hoisted_44
    ]),
    _hoisted_49,
    createBaseVNode("p", null, [
      createTextVNode("更多参考 官方："),
      createBaseVNode("a", _hoisted_53, [
        createTextVNode("https://github.com/GoogleContainerTools/kaniko#additional-flags"),
        createVNode(_component_ExternalLinkIcon)
      ])
    ]),
    _hoisted_54
  ]);
}
const ruheshiyongKanikozai_Kubernetes_jiqunzhonggoujianrongqijingxiang_html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "ruheshiyongKanikozai Kubernetes jiqunzhonggoujianrongqijingxiang.html.vue"]]);
export {
  ruheshiyongKanikozai_Kubernetes_jiqunzhonggoujianrongqijingxiang_html as default
};
