import { _ as _export_sfc, r as resolveComponent, o as openBlock, c as createElementBlock, b as createBaseVNode, d as createTextVNode, e as createVNode, a as createStaticVNode } from "./app-d515af8b.js";
const _sfc_main = {};
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h2 id="引言" tabindex="-1"><a class="header-anchor" href="#引言" aria-hidden="true">#</a> 引言</h2><p>Kubernetes出现的报错如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>Failed to create pod sandbox: rpc error: code <span class="token operator">=</span> Unknown desc <span class="token operator">=</span> failed to get sandbox image <span class="token string">&quot;k8s.gcr.io/pause:3.5&quot;</span><span class="token builtin class-name">:</span> failed to pull image <span class="token string">&quot;k8s.gcr.io/pause:3.5&quot;</span><span class="token builtin class-name">:</span> failed to pull and unpack image <span class="token string">&quot;k8s.gcr.io/pause:3.5&quot;</span><span class="token builtin class-name">:</span> failed to resolve reference <span class="token string">&quot;k8s.gcr.io/pause:3.5&quot;</span><span class="token builtin class-name">:</span> failed to <span class="token keyword">do</span> request: Head <span class="token string">&quot;https://k8s.gcr.io/v2/pause/manifests/3.5&quot;</span><span class="token builtin class-name">:</span> x509: certificate signed by unknown authority\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>k8s.gcr.io 这个地址是需要连外网才可以拉取到，导致 pause 镜像拉不下来，Pod无法启动。以前都没关注过 pause 这个容器，它是啥，做什么用的，怎么在 Pod 里没看到过他，本文将带你了解 pause 容器。</p><h2 id="pause容器是个啥" tabindex="-1"><a class="header-anchor" href="#pause容器是个啥" aria-hidden="true">#</a> Pause容器是个啥</h2><p>在Kubernetes中，Pod是最小的调度单元，但它的内部结构却充满了许多复杂的机制，其中之一就是Pause容器。尽管Pause容器看似不起眼，但它在整个Kubernetes集群中发挥了至关重要的作用。 我们在 kubernetes 的 node 节点，执行 docker ps，可以发现每个 node 上都运行了一个 pause进程的容器，具体如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># docker ps |grep traefik</span>\n66032431a20e   2ae1addee1b2                                                     <span class="token string">&quot;/entrypoint.sh --gl…&quot;</span>   <span class="token number">30</span> hours ago     Up <span class="token number">30</span> hours               k8s_traefik_traefik-68b9ccfc77-x8sqg_traefik_aa5b97bf-3db8-4b92-89a7-1fe551645e6a_0\n10d393461904   registry.aliyuncs.com/google_containers/pause:3.5                <span class="token string">&quot;/pause&quot;</span>                 <span class="token number">30</span> hours ago     Up <span class="token number">30</span> hours               k8s_POD_traefik-68b9ccfc77-x8sqg_traefik_aa5b97bf-3db8-4b92-89a7-1fe551645e6a_0\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>会发现有很多 pause 容器运行于服务器上面，容器命名也很规范，然后每次启动一个容器，都会伴随一个pause这样的容器启动。那它究竟是干啥子的？ 它就是 Pause 容器，又叫 Infra 容器。 我们在部署完 kubernetes 集群后，查看 kubelet 进程，可以看到配置中有这样一个参数：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># ps -ef|grep kubelet</span>\nroot      <span class="token number">8675</span>     <span class="token number">1</span> <span class="token number">10</span> Sep18 ?        03:15:07 /usr/bin/kubelet --bootstrap-kubeconfig<span class="token operator">=</span>/etc/kubernetes/bootstrap-kubelet.conf <span class="token parameter variable">--kubeconfig</span><span class="token operator">=</span>/etc/kubernetes/kubelet.conf <span class="token parameter variable">--config</span><span class="token operator">=</span>/var/lib/kubelet/config.yaml --network-plugin<span class="token operator">=</span>cni --pod-infra-container-image<span class="token operator">=</span>registry.aliyuncs.com/google_containers/pause:3.5\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>', 9);
const _hoisted_10 = {
  href: "http://registry.aliyuncs.com/google_containers/pause:3.5",
  target: "_blank",
  rel: "noopener noreferrer"
};
const _hoisted_11 = /* @__PURE__ */ createStaticVNode('<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># docker images|grep pause</span>\nregistry.aliyuncs.com/google_containers/pause                     <span class="token number">3.5</span>        ed210e3e4a5b   <span class="token number">2</span> years ago     683kB\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>', 1);
const _hoisted_12 = {
  href: "https://github.com/kubernetes/kubernetes/tree/master/build/pause",
  target: "_blank",
  rel: "noopener noreferrer"
};
const _hoisted_13 = /* @__PURE__ */ createStaticVNode('<h2 id="pause容器的作用" tabindex="-1"><a class="header-anchor" href="#pause容器的作用" aria-hidden="true">#</a> Pause容器的作用</h2><ol><li><strong>网络命名空间隔离</strong>：Pod是Kubernetes中最小的调度单元，可以包含一个或多个容器。为了实现容器之间的网络隔离，每个Pod都有自己独立的网络命名空间。Pause容器负责创建并维护这个网络命名空间，其他容器共享这个网络命名空间，使它们能够相互通信，而不会与其他Pod中的容器发生冲突。</li><li><strong>进程隔离</strong>：Pause容器保持一个轻量级的进程运行，即使Pod中的其他容器都停止了。这个进程实际上不执行任何有用的工作，但它的存在确保了Pod不会在没有容器运行的情况下被删除。当其他容器停止时，Pause容器仍在运行，以维持Pod的生命周期。</li><li><strong>资源隔离</strong>：尽管Pause容器通常不分配大量的CPU和内存资源，但它可以配置以使用一些资源。这有助于确保即使Pod中没有其他容器运行时，Kubernetes仍然可以监控和管理Pod的资源使用情况。这也有助于防止Pod被其他具有相同资源要求的Pod占用。</li><li><strong>IP地址维护</strong>：Pause容器负责维护Pod的IP地址。Pod的IP地址通常是动态分配的，但由于Pause容器一直在运行，它可以维护Pod的IP地址，以便其他容器可以通过该地址进行通信。这有助于确保Pod的IP地址在整个Pod的生命周期内保持一致。</li><li><strong>生命周期管理</strong>：Pause容器的生命周期与Pod的生命周期相同。当Pod创建时，Pause容器被创建；当Pod删除时，Pause容器也会被删除。这确保了Pod的整个生命周期都由Kubernetes进行管理，包括创建、扩展、缩放和删除。</li></ol><h2 id="pause容器工作原理" tabindex="-1"><a class="header-anchor" href="#pause容器工作原理" aria-hidden="true">#</a> Pause容器工作原理</h2><p>一个 Pod 可以由一组容器组成的，这些容器之间共享存储和网络资源，那么网络资源是如何共享的呢？下面是个例子： <img src="https://img.kubesre.com/kubesre/20230913/pa.png" alt="image.png"> 比如说现在有一个 Pod，其中包含了一个容器 A 和一个容器 B，它们两个就要共享 Network Namespace。在 Kubernetes 里的解法是这样的：它会在每个 Pod 里，额外起一个 Infra container 小容器来共享整个 Pod 的 Network Namespace。Infra container 是一个非常小的镜像，大概 683kB，是一个C语言写的、永远处于“暂停”状态的容器。由于有了这样一个 Infra container 之后，其他所有容器都会通过 Join Namespace 的方式加入到 Infra container 的 Network Namespace 中。 所以说一个 Pod 里面的所有容器，它们看到的网络视图可以说是完全一样的。即：它们看到的网络设备、IP地址、Mac地址等等，跟网络相关的信息，其实全是一份，这一份都来自于 Pod 第一次创建的这个 Infra container。这就是 Pod 解决网络共享的一个解法。 在 Pod 里面，一定有一个 IP 地址，是这个 Pod 的 Network Namespace 对应的地址，也是这个 Infra container 的 IP 地址。所以大家看到的都是一份，而其他所有网络资源，都是一个 Pod 一份，并且被 Pod 中的所有容器共享。这就是 Pod 的网络实现方式。 由于需要有一个相当于说中间的容器存在，所以整个 Pod 里面，必然是 Infra container 第一个启动。并且整个 Pod 的生命周期是等同于 Infra container 的生命周期的，与容器 A 和 B 是无关的。这是非常重要的一个设计。 kubernetes的pause容器主要为每个业务容器提供两个核心功能：</p><ul><li>第一，它提供整个pod的Linux命名空间的基础。</li><li>第二，启用PID命名空间，它在每个pod中都作为PID为1的进程，并回收僵尸进程。</li></ul><h2 id="手工模拟pod" tabindex="-1"><a class="header-anchor" href="#手工模拟pod" aria-hidden="true">#</a> 手工模拟Pod</h2><p>我们已经知道，一个 Pod 从表面上来看至少由一个容器组成，而实际上一个 Pod 至少要有包含两个容器，一个是应用容器，一个是 pause 容器。 运行一个pause容器：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># docker run -d --name pause -p 8080:80 registry.aliyuncs.com/google_containers/pause:3.5</span>\nfd315974f5d1a5f52ca47c5dc31aea3774cebf90c88ce065cc9e9ea2f52c103c\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>--name：指定 pause 容器的名字，pause</li><li>-p 8080:80：将宿主机的 8080 端口映射到容器的 80 端口</li></ul><p>运行一个nginx容器，代理 127.0.0.1:8888 springboot应用程序</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 准备nginx配置文件</span>\n<span class="token punctuation">[</span>root@k8s001 ~<span class="token punctuation">]</span><span class="token comment"># cat &lt;&lt;EOF &gt;&gt; nginx.conf</span>\nerror_log stderr<span class="token punctuation">;</span>\nevents <span class="token punctuation">{</span> worker_connections  <span class="token number">1024</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>\nhttp <span class="token punctuation">{</span>\n    server <span class="token punctuation">{</span>\n        listen <span class="token number">80</span> default_server<span class="token punctuation">;</span>\n        server_name www.kubesre.com<span class="token punctuation">;</span>\n        location / <span class="token punctuation">{</span>\n            proxy_pass http://127.0.0.1:8888<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\nEOF\n \n<span class="token comment"># 创建nginx容器</span>\n<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># docker run -d --name nginx -v `pwd`/nginx.conf:/etc/nginx/nginx.conf --net=container:pause --ipc=container:pause --pid=container:pause --ipc=shareable nginx</span>\nfa9f858adae826ad536178747e00fffc829c7baf98c3bc29e945230abbf2a5cb\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>--net=container:pause：用于与另一个容器共享网络命名空间。在这种情况下，容器 &quot;nginx&quot; 会与名为 &quot;pause&quot; 的容器共享网络命名空间，它们可以使用相同的网络配置和接口。</li><li>--ipc=container:pause：用于与另一个容器共享 IPC 命名空间。IPC 命名空间允许容器之间进行进程间通信（Inter-Process Communication），在这里，容器 &quot;nginx&quot; 与名为 &quot;pause&quot; 的容器共享 IPC 命名空间。</li><li>--pid=container:pause：用于与另一个容器共享 PID 命名空间。PID 命名空间允许容器查看和管理其他容器的进程。</li><li>--ipc=shareable：指示 IPC 命名空间是可共享的，以便其他容器也可以加入到这个共享命名空间中。</li></ul><p>创建一个应用容器 springboot</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># docker run -d --name springboot --net=container:pause --ipc=container:pause --pid=container:pause --ipc=shareable registry.cn-shanghai.aliyuncs.com/kubesre02/springboot</span>\ne33cfa3cebd5aafa714ca6ef0f6a16be52a282c64b8d24b2d98890ccf02c436a\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>到这里，我们就纯手工模拟出了一个符合 K8S Pod 模型的 “Pod” ，只是它并不由 K8S 进行管理。 验证，查看运行的容器</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>\n<span class="token punctuation">[</span>root@localhost <span class="token punctuation">]</span>~<span class="token comment"># docker ps | grep -E &quot;pause|nginx|springboot&quot;</span>\n4f877cdcba5d   registry.cn-shanghai.aliyuncs.com/kubesre02/springboot   <span class="token string">&quot;java -jar /app.jar&quot;</span>     <span class="token number">3</span> seconds ago   Up <span class="token number">2</span> seconds                                               springboot\ne541dc010fb3   nginx                                                    <span class="token string">&quot;/docker-entrypoint.…&quot;</span>   <span class="token number">19</span> hours ago    Up <span class="token number">19</span> hours                                                nginx\n09f94a052d50   registry.aliyuncs.com/google_containers/pause:3.5        <span class="token string">&quot;/pause&quot;</span>                 <span class="token number">19</span> hours ago    Up <span class="token number">19</span> hours    <span class="token number">0.0</span>.0.0:8080-<span class="token operator">&gt;</span><span class="token number">80</span>/tcp, :::8080-<span class="token operator">&gt;</span><span class="token number">80</span>/tcp       pause\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过浏览器访问 http://ip:8080 端口</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># curl http://localhost:8080</span>\nHello Docker World\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的步骤可见：</p><ul><li>pause容器将内部80端口映射到宿主机8080端口。</li><li>pause容器在宿主机上设置好网络namespace后，nginx容器加入到该网络的namespace中。</li><li>nginx容器启动的时候指定了-net=container:pause。</li><li>springboot 容器启动时，同样方式加入到该网络的namespace中。</li><li>这样三个容器共享了网络，互相之间就可以使用localhost直接通信。</li><li>--ipc=container:pause，--pid=container:pause就是三个容器的ipc和pid处于同一个namespace中，init进程为pause。</li></ul><p>这里，我们进入springboot 容器内部查看：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># /tmp/test# docker exec -it springboot sh</span>\n/ <span class="token comment"># ps aux</span>\nPID   <span class="token environment constant">USER</span>     TIME   COMMAND\n    <span class="token number">1</span> <span class="token number">65535</span>      <span class="token number">0</span>:00 /pause\n  <span class="token number">205</span> root       <span class="token number">0</span>:22 <span class="token function">java</span> <span class="token parameter variable">-jar</span> /app.jar\n  <span class="token number">240</span> root       <span class="token number">0</span>:00 nginx: master process nginx <span class="token parameter variable">-g</span> daemon off<span class="token punctuation">;</span>\n  <span class="token number">261</span> <span class="token number">101</span>        <span class="token number">0</span>:00 nginx: worker process\n  <span class="token number">263</span> root       <span class="token number">0</span>:00 <span class="token function">sh</span>\n  <span class="token number">269</span> root       <span class="token number">0</span>:00 <span class="token function">ps</span> aux\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在springboot 容器中可以看到pause和nginx容器的进程，并且pause容器的PID为1，而在kubernetes中容器的PID=1的进程则为容器本身的业务进程。</p><p>如果没有 K8S 的 Pod ，启动一个 业务容器，你需要手动创建三个容器，当你想销毁这个服务时，同样需要删除三个容器。而有了 K8S 的 Pod，这三个容器在逻辑上就是一个整体，创建 Pod 就会自动创建三个容器，删除 Pod 就会删除三个容器，从管理上来讲，方便了不少。</p><p>这正是 Pod 存在的一个根本意义所在。</p><h2 id="如何回收僵尸进程" tabindex="-1"><a class="header-anchor" href="#如何回收僵尸进程" aria-hidden="true">#</a> 如何回收僵尸进程</h2><p>在Linux中，PID命名空间中的进程是一个树型结构，每个进程有一个父进程。在树的根上只有一个进程没有真正的父进程。这是init进程，其PID为1。</p><p>僵尸进程是指已经停止运行但它们的进程表条目仍然存在的进程，在UNIX系统中，一个子进程结束了，但是它的父进程没有等待(调用wait/waitpid)它，那么它将变成一个僵尸进程。</p><p>僵尸进程是怎么产生的？</p><p>出现僵尸进程的一种情况是： 父进程编写得很糟糕，省略了wait调用，或者父进程意外崩溃在子进程之前死亡，而新的父进程没有调用wait。当一个进程的父进程在子进程之前死亡时，操作系统将该子进程分配给init进程或PID 1的进程。即init进程接纳子进程并成为其父进程。这意味着，现在当子进程退出时，新的父进程(init)必须调用wait来获取它的退出码，否则它的进程表条目将永远保留下来，成为僵死进程。</p><p>在Kubernetes pod中，容器的运行方式与上述基本相同，但是为每个pod创建了一个特殊的pause容器。</p><p>这个pause容器运行了一个非常简单的进程，它不执行任何函数，本质上永远休眠，其源码实现：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>/*\nCopyright <span class="token number">2016</span> The Kubernetes Authors.\nLicensed under the Apache License, Version <span class="token number">2.0</span> <span class="token punctuation">(</span>the <span class="token string">&quot;License&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nyou may not use this <span class="token function">file</span> except <span class="token keyword">in</span> compliance with the License.\nYou may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to <span class="token keyword">in</span> writing, software\ndistributed under the License is distributed on an <span class="token string">&quot;AS IS&quot;</span> BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License <span class="token keyword">for</span> the specific language governing permissions and\nlimitations under the License.\n*/\n \n<span class="token comment">#include &lt;signal.h&gt;</span>\n<span class="token comment">#include &lt;stdio.h&gt;</span>\n<span class="token comment">#include &lt;stdlib.h&gt;</span>\n<span class="token comment">#include &lt;sys/types.h&gt;</span>\n<span class="token comment">#include &lt;sys/wait.h&gt;</span>\n<span class="token comment">#include &lt;unistd.h&gt;</span>\n \nstatic void sigdown<span class="token punctuation">(</span>int signo<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  psignal<span class="token punctuation">(</span>signo, <span class="token string">&quot;Shutting down, got signal&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  exit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n \nstatic void sigreap<span class="token punctuation">(</span>int signo<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">while</span> <span class="token punctuation">(</span>waitpid<span class="token punctuation">(</span>-1, NULL, WNOHANG<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n \nint <span class="token function-name function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span>\n    /* Not an error because pause sees use outside of infra containers. */\n    fprintf<span class="token punctuation">(</span>stderr, <span class="token string">&quot;Warning: pause should be the first process<span class="token entity" title="\\n">\\n</span>&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n \n  <span class="token keyword">if</span> <span class="token punctuation">(</span>sigaction<span class="token punctuation">(</span>SIGINT, <span class="token operator">&amp;</span><span class="token punctuation">(</span>struct sigaction<span class="token punctuation">)</span><span class="token punctuation">{</span>.sa_handler <span class="token operator">=</span> sigdown<span class="token punctuation">}</span>, NULL<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>\n    <span class="token builtin class-name">return</span> <span class="token number">1</span><span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>sigaction<span class="token punctuation">(</span>SIGTERM, <span class="token operator">&amp;</span><span class="token punctuation">(</span>struct sigaction<span class="token punctuation">)</span><span class="token punctuation">{</span>.sa_handler <span class="token operator">=</span> sigdown<span class="token punctuation">}</span>, NULL<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>\n    <span class="token builtin class-name">return</span> <span class="token number">2</span><span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>sigaction<span class="token punctuation">(</span>SIGCHLD, <span class="token operator">&amp;</span><span class="token punctuation">(</span>struct sigaction<span class="token punctuation">)</span><span class="token punctuation">{</span>.sa_handler <span class="token operator">=</span> sigreap,\n                                             .sa_flags <span class="token operator">=</span> SA_NOCLDSTOP<span class="token punctuation">}</span>,\n                NULL<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>\n    <span class="token builtin class-name">return</span> <span class="token number">3</span><span class="token punctuation">;</span>\n \n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>\n    pause<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  fprintf<span class="token punctuation">(</span>stderr, <span class="token string">&quot;Error: infinite loop terminated<span class="token entity" title="\\n">\\n</span>&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token builtin class-name">return</span> <span class="token number">42</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上述代码种我们可以发现，pause容器不仅仅调用pause()使进程休眠，还拥有另外一个重要的功能：</p><p>它假定自己为PID 1的角色，当僵尸进程被其父进程孤立时，会被pause容器进行收养，通过调用wait来获取僵尸进程。 这样一来就不会在Kubernetes pod的PID命名空间中堆积僵尸进程了。</p><p>那为啥使用 kubectl create 或 kubectl apply 等命令创建Pod时，通常不会显式地看到Pause容器。这是因为Pause容器是由Kubernetes自动创建和管理的，通常不需要用户手动操作或关注。它是Pod的一个隐式组成部分，用于维护Pod的基础设施和容器之间的网络隔离。</p><p>不难想到，这其中的过程是非常复杂的。而且我们还没有深入探讨如何去监控和管理这些容器的生命周期。但是不用担心，我们不需要这么复杂的去管理我们的容器，因为kubernetes已经都为我们做好了。</p>', 37);
function _sfc_render(_ctx, _cache) {
  const _component_ExternalLinkIcon = resolveComponent("ExternalLinkIcon");
  return openBlock(), createElementBlock("div", null, [
    _hoisted_1,
    createBaseVNode("p", null, [
      createTextVNode("pause 容器使用的镜像为 "),
      createBaseVNode("a", _hoisted_10, [
        createTextVNode("registry.aliyuncs.com/google_containers/pause:3.5"),
        createVNode(_component_ExternalLinkIcon)
      ]),
      createTextVNode(" 该镜像非常小，只有 683kB，由于它总是处于 Pause （暂时）状态，所以取名叫 pause")
    ]),
    _hoisted_11,
    createBaseVNode("blockquote", null, [
      createBaseVNode("p", null, [
        createTextVNode("想了解该 pause 容器的构成（代码是用 C 语言写的）的可以去官方仓库上一看究竟："),
        createBaseVNode("a", _hoisted_12, [
          createTextVNode("https://github.com/kubernetes/kubernetes/tree/master/build/pause"),
          createVNode(_component_ExternalLinkIcon)
        ])
      ])
    ]),
    _hoisted_13
  ]);
}
const KuberneteszhongdePauserongqidaodishiganmade_html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "KuberneteszhongdePauserongqidaodishiganmade.html.vue"]]);
export {
  KuberneteszhongdePauserongqidaodishiganmade_html as default
};
